'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _regeneratorRuntime = _interopDefault(require('babel-runtime/regenerator'));
var _asyncToGenerator = _interopDefault(require('babel-runtime/helpers/asyncToGenerator'));

var _this = undefined;

// Default presence ahead function. Used when node does not provides one.
var defaultPresenceAhead = function defaultPresenceAhead(element) {
  return function (height) {
    return Math.min(element.height, height);
  };
};

// Calculates the presence ahead or an array of nodes, given the available height.
var getPresenceAhead = function getPresenceAhead(elements, height) {
  var result = 0;

  for (var i = 0; i < elements.length; i++) {
    var element = elements[i];
    var isElementInside = height > element.top;
    var presenceAhead = element.presenceAhead || defaultPresenceAhead(element);

    if (element && isElementInside) {
      result += presenceAhead(height - element.top);
    }
  }

  return result;
};

// Clone element recursively including children
var cloneRecursively = function cloneRecursively(node) {
  var clone = node.clone();

  if (node.children && node.children.length > 0) {
    node.children.forEach(function (child) {
      return clone.appendChild(cloneRecursively(child));
    });
  }

  return clone;
};

// Wrap nodes tree in fixed height page, and returns exceedings separately.
var wrap = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(elements, height, pageNumber) {
    var nextPageElements, elementsToBeRemoved, i, element, futureElements, isElementOutside, elementShouldSplit, elementShouldBreak, presenceAhead, clone, newFutureElements, nonFixedElements, _ret;

    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            nextPageElements = [];
            elementsToBeRemoved = [];
            i = 0;

          case 3:
            if (!(i < elements.length)) {
              _context2.next = 37;
              break;
            }

            element = elements[i];

            if (!element.nodeWillWrap) {
              _context2.next = 8;
              break;
            }

            _context2.next = 8;
            return element.nodeWillWrap({ pageNumber: pageNumber });

          case 8:
            futureElements = elements.slice(i + 1);
            isElementOutside = height <= element.top;
            elementShouldSplit = height < element.top + element.height;
            elementShouldBreak = element.break || !element.wrap && elementShouldSplit;

            // If element is fixed, we add it both to the current page
            // and to all future pages to come.

            if (!element.fixed) {
              _context2.next = 15;
              break;
            }

            nextPageElements.push(cloneRecursively(element));
            return _context2.abrupt("continue", 34);

          case 15:
            if (!isElementOutside) {
              _context2.next = 19;
              break;
            }

            nextPageElements.push(cloneRecursively(element));
            elementsToBeRemoved.push(element);
            return _context2.abrupt("continue", 34);

          case 19:

            // Checks if element has more than the minimun presence ahead on that page.
            // If not, we break the page in this element.
            if (element.minPresenceAhead) {
              presenceAhead = getPresenceAhead(futureElements, height);

              if (presenceAhead < element.minPresenceAhead) elementShouldBreak = true;
            }

            // Element can break based on many conditions: if has the break flag,
            // if has the wrap flag as false and should be splitted or didn't have enough
            // presence ahead. Either way, the element get's relocated on the next page,
            // as well as all other next elements.

            if (!elementShouldBreak) {
              _context2.next = 29;
              break;
            }

            clone = cloneRecursively(element);
            newFutureElements = futureElements.map(function (element) {
              return cloneRecursively(element);
            });
            nonFixedElements = futureElements.filter(function (element) {
              return !element.fixed;
            });


            clone.top = 0;
            clone.break = false;

            nextPageElements.push.apply(nextPageElements, [clone].concat(newFutureElements));
            elementsToBeRemoved.push.apply(elementsToBeRemoved, [element].concat(nonFixedElements));
            return _context2.abrupt("break", 37);

          case 29:
            if (!elementShouldSplit) {
              _context2.next = 34;
              break;
            }

            return _context2.delegateYield( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
              var clone, remainingHeight, wrappedChildren;
              return _regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      clone = element.clone();
                      remainingHeight = height - element.top;

                      if (!(element.children && element.children.length > 0)) {
                        _context.next = 7;
                        break;
                      }

                      _context.next = 5;
                      return wrap(element.children, remainingHeight);

                    case 5:
                      wrappedChildren = _context.sent;

                      wrappedChildren.forEach(function (child) {
                        return clone.appendChild(child);
                      });

                    case 7:

                      element.onNodeSplit(remainingHeight, clone);
                      nextPageElements.push(clone);

                      return _context.abrupt("return", "continue");

                    case 10:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, _this);
            })(), "t0", 31);

          case 31:
            _ret = _context2.t0;

            if (!(_ret === "continue")) {
              _context2.next = 34;
              break;
            }

            return _context2.abrupt("continue", 34);

          case 34:
            i++;
            _context2.next = 3;
            break;

          case 37:

            // Remove elements that didn't fit inside page
            // We do this here to not interfer with upper elements iteration
            elementsToBeRemoved.forEach(function (element) {
              return element.remove();
            });

            return _context2.abrupt("return", nextPageElements);

          case 39:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, _this);
  }));

  return function wrap(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();

// Wrap nodes tree in equal sized subpages
var wrapPages = function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(nodes, height, pageIndex) {
    var wrapResult, nextPage, hasOnlyFixedChilds, nextPages;
    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return wrap(nodes, height, pageIndex++);

          case 2:
            wrapResult = _context3.sent;
            nextPage = wrapResult[0];

            if (!(!nextPage || nextPage.isEmpty())) {
              _context3.next = 6;
              break;
            }

            return _context3.abrupt("return", nodes);

          case 6:
            hasOnlyFixedChilds = nextPage.children.length > 0 && nextPage.children.every(function (c) {
              return c.fixed;
            });

            if (!hasOnlyFixedChilds) {
              _context3.next = 9;
              break;
            }

            return _context3.abrupt("return", nodes);

          case 9:
            _context3.next = 11;
            return wrapPages([nextPage], height, pageIndex);

          case 11:
            nextPages = _context3.sent;
            return _context3.abrupt("return", [].concat(nodes, nextPages));

          case 13:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, _this);
  }));

  return function wrapPages(_x4, _x5, _x6) {
    return _ref2.apply(this, arguments);
  };
}();

var wrapPage = function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(page, height) {
    var pageIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var pages;
    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (page) {
              _context4.next = 2;
              break;
            }

            return _context4.abrupt("return", []);

          case 2:
            _context4.next = 4;
            return wrapPages([cloneRecursively(page)], height, pageIndex);

          case 4:
            pages = _context4.sent;
            return _context4.abrupt("return", pages);

          case 6:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, _this);
  }));

  return function wrapPage(_x8, _x9) {
    return _ref3.apply(this, arguments);
  };
}();

exports.wrap = wrap;
exports['default'] = wrapPage;
