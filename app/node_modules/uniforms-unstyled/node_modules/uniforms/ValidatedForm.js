"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var prop_types_1 = tslib_1.__importDefault(require("prop-types"));
var cloneDeep_1 = tslib_1.__importDefault(require("lodash/cloneDeep"));
var isEqual_1 = tslib_1.__importDefault(require("lodash/isEqual"));
var merge_1 = tslib_1.__importDefault(require("lodash/merge"));
var noop_1 = tslib_1.__importDefault(require("lodash/noop"));
var omit_1 = tslib_1.__importDefault(require("lodash/omit"));
var set_1 = tslib_1.__importDefault(require("lodash/set"));
var BaseForm_1 = tslib_1.__importStar(require("./BaseForm"));
var childContextTypes = BaseForm_1.__childContextTypesBuild(merge_1.default({ state: { validating: prop_types_1.default.bool.isRequired } }, BaseForm_1.__childContextTypes));
var Validated = function (parent) { var _a; return _a = /** @class */ (function (_super) {
        tslib_1.__extends(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, args) || this;
            // @ts-ignore
            _this.state = tslib_1.__assign(tslib_1.__assign({}, _this.state), { error: null, validate: false, validating: false, validator: _this.getChildContextSchema().getValidator(_this.props.validator) });
            _this.onValidate = _this.validate = _this.onValidate.bind(_this);
            _this.onValidateModel = _this.validateModel = _this.onValidateModel.bind(_this);
            return _this;
        }
        class_1.prototype.getChildContextError = function () {
            return _super.prototype.getChildContextError.call(this) || this.state.error;
        };
        class_1.prototype.getChildContextState = function () {
            return tslib_1.__assign(tslib_1.__assign({}, _super.prototype.getChildContextState.call(this)), { validating: this.state.validating });
        };
        class_1.prototype.getNativeFormProps = function () {
            return omit_1.default(_super.prototype.getNativeFormProps.call(this), [
                'onValidate',
                'validate',
                'validator',
            ]);
        };
        class_1.prototype.componentWillReceiveProps = function (_a) {
            var _this = this;
            var model = _a.model, schema = _a.schema, validate = _a.validate, validator = _a.validator;
            // @ts-ignore
            _super.prototype.componentWillReceiveProps.apply(this, arguments);
            if (this.props.schema !== schema || this.props.validator !== validator) {
                this.setState(function (state) { return ({ validator: state.bridge.getValidator(validator) }); }, function () {
                    if (shouldRevalidate(validate, _this.state.validate)) {
                        _this.onValidate().catch(noop_1.default);
                    }
                });
            }
            else if (!isEqual_1.default(this.props.model, model) &&
                shouldRevalidate(validate, this.state.validate)) {
                this.onValidateModel(model).catch(noop_1.default);
            }
        };
        class_1.prototype.onChange = function (key, value) {
            if (shouldRevalidate(this.props.validate, this.state.validate)) {
                this.onValidate(key, value).catch(noop_1.default);
            }
            // FIXME: https://github.com/vazco/uniforms/issues/293
            // if (this.props.validate === 'onSubmit' && this.state.validate) {
            //     this.setState(() => ({error: null}));
            // }
            // @ts-ignore
            _super.prototype.onChange.apply(this, arguments);
        };
        class_1.prototype.__reset = function (state) {
            return tslib_1.__assign(tslib_1.__assign({}, _super.prototype.__reset.call(this, state)), { error: null, validate: false, validating: false });
        };
        class_1.prototype.onSubmit = function (event) {
            var _this = this;
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            var promise = new Promise(function (resolve, reject) {
                _this.setState(function () { return ({ submitting: true, validate: true }); }, function () {
                    _this.onValidate().then(function () {
                        _super.prototype.onSubmit.call(_this).then(resolve, function (error) {
                            _this.setState({ error: error });
                            reject(error);
                        });
                    }, reject);
                });
            });
            promise
                // `onSubmit` should never reject, so we ignore this rejection.
                .catch(noop_1.default)
                .then(function () {
                // It can be already unmounted.
                if (_this.mounted)
                    // If validation fails, or `super.onSubmit` doesn't touch `submitting`, we need to reset it.
                    _this.setState(function (state) {
                        return state.submitting ? { submitting: false } : null;
                    });
            });
            return promise;
        };
        class_1.prototype.onValidate = function (key, value) {
            var model = this.getChildContextModel();
            if (model && key) {
                model = set_1.default(cloneDeep_1.default(model), key, cloneDeep_1.default(value));
            }
            return this.onValidateModel(model);
        };
        class_1.prototype.onValidateModel = function (model) {
            var _this = this;
            // @ts-ignore
            model = this.getModel('validate', model);
            var catched = this.props.error || null;
            try {
                this.state.validator(model);
            }
            catch (error) {
                catched = error;
            }
            this.setState({ validating: true });
            return new Promise(function (resolve, reject) {
                _this.props.onValidate(model, catched, function (error) {
                    if (error === void 0) { error = catched; }
                    // Do not copy error from props to state.
                    _this.setState(function () { return ({
                        error: error === _this.props.error ? null : error,
                        validating: false,
                    }); }, function () {
                        if (error) {
                            reject(error);
                        }
                        else {
                            resolve();
                        }
                    });
                });
            });
        };
        return class_1;
    }(parent)),
    _a.Validated = Validated,
    _a.displayName = "Validated" + parent.displayName,
    _a.defaultProps = tslib_1.__assign(tslib_1.__assign({}, parent.defaultProps), { onValidate: function (model, error, callback) {
            callback();
        }, validate: 'onChangeAfterSubmit' }),
    _a.propTypes = tslib_1.__assign(tslib_1.__assign({}, parent.propTypes), { onValidate: prop_types_1.default.func.isRequired, validator: prop_types_1.default.any, validate: prop_types_1.default.oneOf(['onChange', 'onChangeAfterSubmit', 'onSubmit'])
            .isRequired }),
    _a.childContextTypes = tslib_1.__assign(tslib_1.__assign({}, (parent.childContextTypes || {})), { uniforms: childContextTypes }),
    _a; };
function shouldRevalidate(inProps, inState) {
    return (inProps === 'onChange' || (inProps === 'onChangeAfterSubmit' && inState));
}
exports.default = Validated(BaseForm_1.default);
